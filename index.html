<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Bot Comparison Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-active {
            overflow-x: hidden;
            overflow-y: auto;
        }
        .chart-container {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .prose { max-width: none; }
        /* Sortable table header */
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 1.5rem; /* Space for arrows */
        }
        .sortable:after, .sortable:before {
            content: "";
            position: absolute;
            right: 0.5em;
            border: 4px solid transparent;
        }
        .sortable:before {
            top: 0.75em;
            border-bottom-color: #9ca3af;
        }
        .sortable:after {
            bottom: 0.75em;
            border-top-color: #9ca3af;
        }
        .sortable[data-sort-dir="asc"]:before {
            border-bottom-color: #374151;
        }
        .sortable[data-sort-dir="desc"]:after {
            border-top-color: #374151;
        }
        /* Pagination */
        .pagination-btn {
            transition: background-color 0.3s ease;
        }
        .pagination-btn.active {
            background-color: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }
        .pagination-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -120px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="antialiased text-gray-800">

<div id="loading-overlay" class="fixed top-0 left-0 w-full h-full bg-white bg-opacity-75 flex justify-center items-center z-50">
    <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32" style="border-top-color: #4f46e5; animation: spin 1s linear infinite;"></div>
    <style>@keyframes spin { to { transform: rotate(360deg); } }</style>
</div>

<div class="container mx-auto px-4 sm:px-8 py-8">
    <div class="py-8">
        <div>
            <h1 class="text-3xl font-bold leading-tight text-gray-900">Crypto Bot Performance Dashboard</h1>
            <p class="mt-2 text-lg text-gray-600">A comparative analysis of the top trading bots.</p>
        </div>
        <!-- Ranking Formula Display -->
        <div class="my-6 p-4 bg-white rounded-lg shadow">
            <h3 class="font-bold text-lg mb-2">Bot Ranking Formula</h3>
            <p class="text-sm text-gray-600">Bots are ranked based on a weighted score calculated from the Z-scores of live performance metrics. A Z-score indicates how many standard deviations a value is from the mean.</p>
            <code class="block bg-gray-100 p-2 rounded mt-2 text-xs">Score = (0.30 * Z(Monthly Return)) + (0.30 * Z(Sharpe Ratio)) + (0.20 * Z(Calmar Ratio)) - (0.10 * Z(Max Drawdown)) - (0.10 * Z(Recovery Time))</code>
        </div>
        <div class="my-5 flex justify-between items-center sm:flex-row flex-col">
            <div class="relative">
                     <span class="absolute inset-y-0 left-0 flex items-center pl-2">
                        <svg viewBox="0 0 24 24" class="h-4 w-4 fill-current text-gray-500"><path d="M10 4a6 6 0 100 12 6 6 0 000-12zm-8 6a8 8 0 1114.32 4.906l5.387 5.387a1 1 0 01-1.414 1.414l-5.387-5.387A8 8 0 012 10z"></path></svg>
                    </span>
                <input placeholder="Search by bot name..." id="bot-search" class="appearance-none rounded-md border border-gray-400 block pl-8 pr-6 py-2 w-full bg-white text-sm placeholder-gray-400 text-gray-700 focus:bg-white focus:placeholder-gray-600 focus:text-gray-700 focus:outline-none" />
            </div>
            <div class="flex items-center justify-center mt-4 sm:mt-0 space-x-4">
                <button id="export-csv-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700">Export to CSV</button>
                <div class="flex items-center">
                    <span class="text-sm font-medium text-gray-900 mr-3">Live Data</span>
                    <label for="table-data-toggle" class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="table-data-toggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-indigo-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                    <span class="text-sm font-medium text-gray-900 ml-3">Backtest Data</span>
                </div>
            </div>
        </div>
        <div class="-mx-4 sm:-mx-8 px-4 sm:px-8 py-4 overflow-x-auto">
            <div class="inline-block min-w-full shadow rounded-lg overflow-hidden">
                <table class="min-w-full leading-normal">
                    <thead id="main-table-head">
                    <tr>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="rank">Rank</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="bot_name">Bot Name</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="monthly_return">Monthly Return (%)</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="return">Return (%)</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="trades">Trades</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="market_change">Market Change (%)</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="expected_drawdown">Exp. Drawdown (%)</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="recovery_days">Recovery Days</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="exec_days">Exec. Days</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="avg_duration">Avg. Duration</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sortable" data-sort-key="score">Score</th>
                        <th class="px-5 py-3 border-b-2 border-gray-200 bg-gray-100"></th>
                    </tr>
                    </thead>
                    <tbody id="bots-table-body">
                    <!-- Bot data will be dynamically inserted here -->
                    </tbody>
                </table>
                <div id="pagination-controls" class="px-5 py-5 bg-white border-t flex flex-col xs:flex-row items-center xs:justify-between">
                    <!-- Pagination will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Bot Selector for Charts -->
        <div class="my-8 p-4 border rounded-md bg-white">
            <div class="flex justify-between items-center mb-4">
                <label class="block text-lg font-medium text-gray-700">Select Bots for Charts (up to 10)</label>
                <button id="reset-bot-selector" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-md hover:bg-gray-300 text-sm">Reset to Default</button>
            </div>
            <input type="text" id="bot-selector-search" placeholder="Search bots..." class="w-full p-2 border rounded-md mb-4">
            <div id="bot-selector-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 max-h-60 overflow-y-auto">
                <!-- Checkboxes will be dynamically inserted here -->
            </div>
        </div>

        <!-- Charts -->
        <div class="mt-8 grid grid-cols-1 xl:grid-cols-2 gap-8">
            <div class="chart-container">
                <div class="flex justify-between items-center mb-4">
                    <h2 id="risk-chart-title" class="text-xl font-bold leading-tight text-gray-900 text-center">Risk & Performance Metrics (Live)</h2>
                    <div class="flex items-center justify-center">
                        <span class="text-sm font-medium text-gray-900 mr-3">Live</span>
                        <label for="performance-toggle" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" value="" id="performance-toggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-indigo-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                        <span class="text-sm font-medium text-gray-900 ml-3">Backtest</span>
                    </div>
                </div>
                <canvas id="riskPerformanceChart"></canvas>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-1 gap-8">
                <div class="chart-container">
                    <h2 class="text-xl font-bold leading-tight text-gray-900 mb-4 text-center">Selected Bots: Live vs. Backtest Avg. Monthly Return (%)</h2>
                    <canvas id="returnChart"></canvas>
                </div>
                <div class="chart-container">
                    <h2 class="text-xl font-bold leading-tight text-gray-900 mb-4 text-center">Selected Bots: Live vs. Backtest Sharpe Ratio</h2>
                    <canvas id="sharpeChart"></canvas>
                </div>
            </div>
        </div>

        <!-- New Charts -->
        <div class="mt-8 grid grid-cols-1 xl:grid-cols-2 gap-8">
            <div class="chart-container">
                <h2 class="text-xl font-bold leading-tight text-gray-900 mb-4 text-center">Selected Bots: Strategy Analysis (Live)</h2>
                <canvas id="strategyChart"></canvas>
            </div>
            <div class="chart-container">
                <h2 class="text-xl font-bold leading-tight text-gray-900 mb-4 text-center tooltip">
                    Selected Bots: Efficiency View (Live)
                    <span class="tooltiptext">This chart shows bot efficiency. Bubbles represent bots, with position indicating market exposure (X-axis) vs. return (Y-axis). Bubble size reflects trade frequency. Ideal bots are in the top-left (high return, low exposure).</span>
                </h2>
                <canvas id="efficiencyChart"></canvas>
            </div>
        </div>
        <div class="mt-8 grid grid-cols-1 gap-8">
            <div class="chart-container">
                <h2 class="text-xl font-bold leading-tight text-gray-900 mb-4 text-center">Selected Bots: Performance vs. Market (Live)</h2>
                <canvas id="marketPerformanceChart"></canvas>
            </div>
        </div>

        <!-- Quarterly Report Chart -->
        <div class="mt-8 grid grid-cols-1 gap-8">
            <div class="chart-container">
                <h2 class="text-xl font-bold leading-tight text-gray-900 mb-4 text-center">Time-Series Performance Report</h2>
                <div class="flex flex-wrap items-center justify-center gap-4 mb-4">
                    <select id="timeframe-selector" class="rounded-md border-gray-300 shadow-sm">
                        <option value="quarterly">Quarterly</option>
                        <option value="yearly">Yearly</option>
                        <option value="weekly">Weekly</option>
                    </select>
                    <input type="date" id="start-date" class="rounded-md border-gray-300 shadow-sm">
                    <input type="date" id="end-date" class="rounded-md border-gray-300 shadow-sm">
                    <div class="flex items-center">
                        <span class="text-sm font-medium text-gray-900 mr-3">Live</span>
                        <label for="quarterly-data-toggle" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="quarterly-data-toggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-indigo-600 peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div>
                        </label>
                        <span class="text-sm font-medium text-gray-900 ml-3">Backtest</span>
                    </div>
                    <button id="apply-filter-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700">Apply</button>
                </div>
                <canvas id="quarterlyPerformanceChart"></canvas>
            </div>
        </div>

    </div>
</div>

<!-- Modal -->
<div class="modal opacity-0 pointer-events-none fixed w-full h-full top-0 left-0 flex items-center justify-center">
    <div class="modal-overlay absolute w-full h-full bg-gray-900 opacity-50"></div>
    <div class="modal-container bg-white w-11/12 md:max-w-4xl mx-auto rounded-lg shadow-lg z-50 overflow-y-auto" style="max-height: 90vh;">
        <div class="modal-close absolute top-0 right-0 cursor-pointer flex flex-col items-center mt-4 mr-4 text-white text-sm z-50">
            <svg class="fill-current text-white" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path d="M14.53 4.53l-1.06-1.06L9 7.94 4.53 3.47 3.47 4.53 7.94 9l-4.47 4.47 1.06 1.06L9 10.06l4.47 4.47 1.06-1.06L10.06 9z"></path></svg>
        </div>
        <div class="modal-content py-4 text-left px-6">
            <div class="flex justify-between items-center pb-3">
                <p class="text-2xl font-bold" id="modal-bot-name"></p>
                <div class="modal-close cursor-pointer z-50"><svg class="fill-current text-black" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path d="M14.53 4.53l-1.06-1.06L9 7.94 4.53 3.47 3.47 4.53 7.94 9l-4.47 4.47 1.06 1.06L9 10.06l4.47 4.47 1.06-1.06L10.06 9z"></path></svg></div>
            </div>
            <div id="modal-bot-details" class="text-base leading-relaxed"></div>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- GLOBAL STATE ---
        let allBotsData = [];
        let reportData = {};
        let chartInstances = {};
        let globalMetricsStats = {};
        let currentSort = { key: 'rank', direction: 'asc' };
        let currentPage = 1;
        const rowsPerPage = 10;
        let selectedBotsForCharts = [];

        // --- DATA FETCHING ---
        async function fetchBotData() {
            const response = await fetch('./crypto_bot_summary.json');
            if (!response.ok) throw new Error(`Failed to fetch crypto_bot_summary.json: ${response.statusText}`);
            return await response.json();
        }

        async function fetchReportData() {
            const response = await fetch('./unified_bot_report.md');
            if (!response.ok) throw new Error(`Failed to fetch unified_bot_report.md: ${response.statusText}`);
            const markdown = await response.text();
            const report = {};
            const sections = markdown.split(/\n###\s*\d*\.?\s*/).slice(1);
            sections.forEach(section => {
                const lines = section.split('\n');
                const botName = lines[0].trim();
                const analysisMarkdown = lines.slice(1).join('\n').trim();
                if (botName && analysisMarkdown) {
                    report[botName] = marked.parse(analysisMarkdown);
                }
            });
            return report;
        }

        // --- MATH HELPERS ---
        function calculateMean(data) {
            return data.reduce((a, b) => a + b, 0) / data.length;
        }

        function calculateStdDev(data, mean) {
            const sqDiff = data.map(n => Math.pow(n - mean, 2));
            const avgSqDiff = calculateMean(sqDiff);
            return Math.sqrt(avgSqDiff);
        }

        function standardize(value, mean, stdDev) {
            if (stdDev === 0) return 0;
            return (value - mean) / stdDev;
        }

        // --- UI RENDERING & LOGIC ---
        function populateTable(bots) {
            const tableBody = document.getElementById('bots-table-body');
            const isBacktest = document.getElementById('table-data-toggle').checked;
            tableBody.innerHTML = '';

            bots.forEach((bot) => {
                const perfKey = isBacktest ? 'backtest_performance' : 'live_performance';
                const expectKey = isBacktest ? 'backtest_bot_expectation' : 'live_bot_expectation';

                const monthlyReturn = bot[expectKey]?.['expected_avg_return (%)']?.toFixed(2) ?? 'N/A';
                const returnValue = bot[perfKey]?.['Return (%)']?.toFixed(2) ?? 'N/A';
                const trades = bot[perfKey]?.['Number of Trades'] ?? 'N/A';
                const marketChange = bot[perfKey]?.['Market Change (%)']?.toFixed(2) ?? 'N/A';
                const expDrawdown = bot[perfKey]?.['Worst Expected Drawdown (%)']?.toFixed(2) ?? 'N/A';
                const recoveryDays = bot[perfKey]?.['Maximum Recovery Time (Days)'] ?? 'N/A';
                const execDays = parseInt(bot[perfKey]?.['Number of Execution Days']) || 'N/A';
                const avgDuration = bot[perfKey]?.['Average Position’s Duration'] ?? 'N/A';

                const row = document.createElement('tr');
                row.innerHTML = `
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${bot.rank}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap font-semibold">${bot.bot_name}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${monthlyReturn}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${returnValue}%</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${trades}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${marketChange}%</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${expDrawdown}%</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${recoveryDays}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${execDays}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap">${avgDuration}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm"><p class="text-gray-900 whitespace-no-wrap font-semibold">${bot.score.toFixed(2)}</p></td>
                        <td class="px-5 py-5 border-b border-gray-200 bg-white text-sm text-right"><button data-bot-id="${bot.bot_id}" class="view-details-btn text-indigo-600 hover:text-indigo-900 font-semibold">Details</button></td>
                    `;
                tableBody.appendChild(row);
            });
        }

        function destroyChart(chartId) {
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
            }
        }

        function createBarCharts(bots) {
            const botNames = bots.map(b => b.bot_name);
            destroyChart('returnChart');
            destroyChart('sharpeChart');

            const returnCtx = document.getElementById('returnChart').getContext('2d');
            chartInstances.returnChart = new Chart(returnCtx, {
                type: 'bar',
                data: {
                    labels: botNames,
                    datasets: [
                        { label: 'Live Avg. Monthly Return', data: bots.map(b => b.live_bot_expectation['expected_avg_return (%)'] || 0), backgroundColor: 'rgba(54, 162, 235, 0.6)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1 },
                        { label: 'Backtest Avg. Monthly Return', data: bots.map(b => b.backtest_bot_expectation['expected_avg_return (%)'] || 0), backgroundColor: 'rgba(255, 99, 132, 0.6)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }
                    ]
                },
                options: { responsive: true, scales: { y: { beginAtZero: true } } }
            });

            const sharpeCtx = document.getElementById('sharpeChart').getContext('2d');
            chartInstances.sharpeChart = new Chart(sharpeCtx, {
                type: 'bar',
                data: {
                    labels: botNames,
                    datasets: [
                        { label: 'Live Sharpe Ratio', data: bots.map(b => b.live_performance['Sharpe Ratio'] || 0), backgroundColor: 'rgba(75, 192, 192, 0.6)', borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 1 },
                        { label: 'Backtest Sharpe Ratio', data: bots.map(b => b.backtest_performance['Sharpe Ratio'] || 0), backgroundColor: 'rgba(255, 206, 86, 0.6)', borderColor: 'rgba(255, 206, 86, 1)', borderWidth: 1 }
                    ]
                },
                options: { responsive: true, scales: { y: { beginAtZero: true } } }
            });
        }

        function updateRiskPerformanceRadar(bots, mode = 'live') {
            destroyChart('riskPerformanceChart');

            const titleEl = document.getElementById('risk-chart-title');
            titleEl.textContent = `Risk & Performance Metrics (${mode.charAt(0).toUpperCase() + mode.slice(1)})`;

            const perfKey = mode === 'live' ? 'live_performance' : 'backtest_performance';
            const expectKey = mode === 'live' ? 'live_bot_expectation' : 'backtest_bot_expectation';

            const metrics = [
                { label: 'Avg Monthly Return (%)', key: 'expected_avg_return (%)', source: expectKey, abs: false },
                { label: 'Sharpe Ratio', key: 'Sharpe Ratio', source: perfKey, abs: false },
                { label: 'Max Recovery Days', key: 'Maximum Recovery Time (Days)', source: perfKey, abs: true },
                { label: 'Max Drawdown (%)', key: 'Max Drawdown (%)', source: perfKey, abs: true },
            ];

            const datasets = bots.map((bot, index) => {
                const color = `hsl(${(index * 360 / bots.length)}, 70%, 50%)`;
                const originalData = metrics.map(metric => bot[metric.source]?.[metric.key] || 0);

                const scaledData = metrics.map((metric, i) => {
                    const stats = globalMetricsStats[metric.key];
                    if (!stats) return 0;
                    const value = metric.abs ? Math.abs(originalData[i]) : originalData[i];
                    return standardize(value, stats.mean, stats.stdDev);
                });

                return {
                    label: bot.bot_name,
                    data: scaledData,
                    originalData: originalData,
                    backgroundColor: `hsla(${(index * 360 / bots.length)}, 70%, 50%, 0.2)`,
                    borderColor: color,
                    pointBackgroundColor: color,
                };
            });

            const riskCtx = document.getElementById('riskPerformanceChart').getContext('2d');
            chartInstances.riskPerformanceChart = new Chart(riskCtx, {
                type: 'radar',
                data: {
                    labels: metrics.map(m => m.label),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const originalValue = context.dataset.originalData[context.dataIndex];
                                    return `${label}: ${originalValue?.toFixed(2) ?? 'N/A'}`;
                                }
                            }
                        }
                    },
                    scales: { r: { beginAtZero: false } } // Z-scores can be negative
                }
            });
        }

        function createNewCharts(bots) {
            destroyChart('strategyChart');
            destroyChart('efficiencyChart');
            destroyChart('marketPerformanceChart');

            // 1. Strategy Analysis: Win Rate vs. Profit/Loss Ratio (Scatter Plot)
            const strategyCtx = document.getElementById('strategyChart').getContext('2d');
            chartInstances.strategyChart = new Chart(strategyCtx, {
                type: 'scatter',
                data: {
                    datasets: bots.map((bot, index) => {
                        const color = `hsl(${(index * 360 / bots.length)}, 70%, 50%)`;
                        return {
                            label: bot.bot_name,
                            data: [{
                                x: bot.live_performance['Profit/Loss Ratio'] || 0,
                                y: bot.live_performance['Win Rate (%)'] || 0
                            }],
                            backgroundColor: color
                        };
                    })
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: {
                        x: { title: { display: true, text: 'Profit/Loss Ratio' } },
                        y: { title: { display: true, text: 'Win Rate (%)' } }
                    }
                }
            });

            // 2. Efficiency View: Time in Market vs. Return (Bubble Chart)
            const efficiencyCtx = document.getElementById('efficiencyChart').getContext('2d');
            chartInstances.efficiencyChart = new Chart(efficiencyCtx, {
                type: 'bubble',
                data: {
                    datasets: bots.map((bot, index) => {
                        const color = `hsl(${(index * 360 / bots.length)}, 70%, 50%)`;
                        return {
                            label: bot.bot_name,
                            data: [{
                                x: bot.live_performance['Time in Market (%)'] || 0,
                                y: bot.live_bot_expectation['expected_avg_return (%)'] || 0,
                                r: (bot.live_performance['Number of Trades'] || 0) / 20 // Scale bubble size
                            }],
                            backgroundColor: `hsla(${(index * 360 / bots.length)}, 70%, 50%, 0.7)`
                        };
                    })
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: {
                        x: { title: { display: true, text: 'Time in Market (%)' } },
                        y: { title: { display: true, text: 'Monthly Return (%)' } }
                    }
                }
            });

            // 3. Performance vs. Market Conditions (Vertical Bar Chart)
            const marketCtx = document.getElementById('marketPerformanceChart').getContext('2d');
            chartInstances.marketPerformanceChart = new Chart(marketCtx, {
                type: 'bar',
                data: {
                    labels: bots.map(b => b.bot_name),
                    datasets: [
                        {
                            label: 'Return (%)',
                            data: bots.map(b => b.live_performance['Return (%)'] || 0),
                            backgroundColor: 'rgba(54, 162, 235, 0.6)'
                        },
                        {
                            label: 'Market Change (%)',
                            data: bots.map(b => b.live_performance['Market Change (%)'] || 0),
                            backgroundColor: 'rgba(255, 99, 132, 0.6)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: { y: { beginAtZero: false } }
                }
            });
        }

        // --- MODAL HANDLING ---
        const modal = document.querySelector('.modal');

        function openModal(botId) {
            const bot = allBotsData.find(b => b.bot_id === botId);
            if (!bot) return;

            document.getElementById('modal-bot-name').innerText = bot.bot_name;
            const modalDetails = document.getElementById('modal-bot-details');

            modalDetails.innerHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <h3 class="font-bold text-lg mb-2 border-b pb-1">Live Performance</h3>
                            <ul class="list-disc list-inside space-y-1 text-gray-700">
                                <li><strong>Return:</strong> ${bot.live_performance['Return (%)']?.toFixed(2) ?? 'N/A'}%</li>
                                <li><strong>Win Rate:</strong> ${bot.live_performance['Win Rate (%)']?.toFixed(2) ?? 'N/A'}%</li>
                                <li><strong>Sharpe Ratio:</strong> ${bot.live_performance['Sharpe Ratio'] ?? 'N/A'}</li>
                                <li><strong>Max Drawdown:</strong> ${bot.live_performance['Max Drawdown (%)'] ?? 'N/A'}%</li>
                                <li><strong>Execution Days:</strong> ${parseInt(bot.live_performance['Number of Execution Days']) || 'N/A'}</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="font-bold text-lg mb-2 border-b pb-1">Backtest Performance</h3>
                            <ul class="list-disc list-inside space-y-1 text-gray-700">
                                <li><strong>Return:</strong> ${bot.backtest_performance['Return (%)']?.toFixed(2) ?? 'N/A'}%</li>
                                <li><strong>Win Rate:</strong> ${bot.backtest_performance['Win Rate (%)']?.toFixed(2) ?? 'N/A'}%</li>
                                <li><strong>Sharpe Ratio:</strong> ${bot.backtest_performance['Sharpe Ratio'] ?? 'N/A'}</li>
                                <li><strong>Max Drawdown:</strong> ${bot.backtest_performance['Max Drawdown (%)'] ?? 'N/A'}%</li>
                                <li><strong>Execution Days:</strong> ${parseInt(bot.backtest_performance['Number of Execution Days']) || 'N/A'}</li>
                            </ul>
                        </div>
                    </div>
                    <div>
                         <h3 class="font-bold text-lg mb-2 border-b pb-1">Analysis</h3>
                         <div class="prose max-w-none max-h-48 overflow-y-auto p-2 border rounded bg-gray-50">${reportData[bot.bot_name] || '<p>No analysis available.</p>'}</div>
                    </div>
                    <div class="mt-4"><canvas id="detailRadarChart"></canvas></div>
                `;

            createDetailRadarChart(bot);
            modal.classList.remove('opacity-0', 'pointer-events-none');
            document.body.classList.add('modal-active');
        }

        function createDetailRadarChart(bot) {
            destroyChart('detailRadarChart');
            const ctx = document.getElementById('detailRadarChart').getContext('2d');

            const metrics = [
                { label: 'Monthly Return (%)', key: 'expected_avg_return (%)', source: 'expectation', abs: false },
                { label: 'Sharpe Ratio', key: 'Sharpe Ratio', source: 'performance', abs: false },
                { label: 'Win Rate (%)', key: 'Win Rate (%)', source: 'performance', abs: false },
                { label: 'Max Drawdown (%)', key: 'Max Drawdown (%)', source: 'performance', abs: true },
                { label: 'Max Recovery Days', key: 'Maximum Recovery Time (Days)', source: 'performance', abs: true }
            ];

            const liveData = metrics.map(m => {
                const sourceObj = m.source === 'performance' ? bot.live_performance : bot.live_bot_expectation;
                return sourceObj?.[m.key] || 0;
            });
            const backtestData = metrics.map(m => {
                const sourceObj = m.source === 'performance' ? bot.backtest_performance : bot.backtest_bot_expectation;
                return sourceObj?.[m.key] || 0;
            });

            const scaledLiveData = liveData.map((val, i) => {
                const metricConfig = metrics[i];
                const stats = globalMetricsStats[metricConfig.key];
                if (!stats) return 0;
                const value = metricConfig.abs ? Math.abs(val) : val;
                return standardize(value, stats.mean, stats.stdDev);
            });

            const scaledBacktestData = backtestData.map((val, i) => {
                const metricConfig = metrics[i];
                const stats = globalMetricsStats[metricConfig.key];
                if (!stats) return 0;
                const value = metricConfig.abs ? Math.abs(val) : val;
                return standardize(value, stats.mean, stats.stdDev);
            });

            chartInstances.detailRadarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: metrics.map(m => m.label),
                    datasets: [
                        {
                            label: 'Live',
                            data: scaledLiveData,
                            originalData: liveData,
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2
                        },
                        {
                            label: 'Backtest',
                            data: scaledBacktestData,
                            originalData: backtestData,
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const originalValue = context.dataset.originalData[context.dataIndex];
                                    return `${label}: ${originalValue?.toFixed(2) ?? 'N/A'}`;
                                }
                            }
                        }
                    },
                    scales: { r: { beginAtZero: false } }
                }
            });
        }

        function closeModal() {
            modal.classList.add('opacity-0', 'pointer-events-none');
            document.body.classList.remove('modal-active');
        }

        // --- DATA PROCESSING & RENDERING ---
        function render() {
            const searchTerm = document.getElementById('bot-search').value.toLowerCase();

            let processedData = allBotsData.filter(bot => bot.bot_name.toLowerCase().includes(searchTerm));

            const sortKey = currentSort.key;
            const sortDir = currentSort.direction === 'asc' ? 1 : -1;
            const isTableBacktest = document.getElementById('table-data-toggle').checked;

            const valueGetter = (bot, key) => {
                const perfKey = isTableBacktest ? 'backtest_performance' : 'live_performance';
                const expectKey = isTableBacktest ? 'backtest_bot_expectation' : 'live_bot_expectation';

                switch (key) {
                    case 'rank': return bot.rank;
                    case 'score': return bot.score;
                    case 'bot_name': return bot.bot_name;
                    case 'monthly_return':
                        return bot[expectKey]?.['expected_avg_return (%)'] || -Infinity;
                    case 'return':
                        return bot[perfKey]?.['Return (%)'] || -Infinity;
                    case 'trades':
                        return bot[perfKey]?.['Number of Trades'] || -Infinity;
                    case 'market_change':
                        return bot[perfKey]?.['Market Change (%)'] || -Infinity;
                    case 'expected_drawdown':
                        return bot[perfKey]?.['Worst Expected Drawdown (%)'] || -Infinity;
                    case 'recovery_days':
                        return bot[perfKey]?.['Maximum Recovery Time (Days)'] || -Infinity;
                    case 'exec_days':
                        return parseInt(bot[perfKey]?.['Number of Execution Days']) || -Infinity;
                    case 'avg_duration':
                        return bot[perfKey]?.['Average Position’s Duration'] || "";
                    default: return 0;
                }
            };

            processedData.sort((a, b) => {
                const valA = valueGetter(a, sortKey);
                const valB = valueGetter(b, sortKey);
                if (typeof valA === 'string' && sortKey === 'bot_name') {
                    return valA.localeCompare(valB) * sortDir;
                }
                if (typeof valA === 'string') return sortDir;
                return (valA - valB) * sortDir;
            });

            const totalPages = Math.ceil(processedData.length / rowsPerPage);
            const paginatedData = processedData.slice((currentPage - 1) * rowsPerPage, currentPage * rowsPerPage);

            populateTable(paginatedData);
            renderPagination(processedData.length, totalPages);
        }

        function renderPagination(totalItems, totalPages) {
            const controls = document.getElementById('pagination-controls');
            if (totalPages <= 1) {
                controls.innerHTML = '';
                return;
            }

            const startItem = (currentPage - 1) * rowsPerPage + 1;
            const endItem = Math.min(currentPage * rowsPerPage, totalItems);

            let buttonsHtml = '';
            for (let i = 1; i <= totalPages; i++) {
                buttonsHtml += `<button class="pagination-btn text-sm bg-white border border-gray-300 text-gray-700 hover:bg-gray-100 font-semibold py-1 px-3 rounded-md mx-1 ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
            }

            controls.innerHTML = `
                    <span class="text-xs xs:text-sm text-gray-900">
                        Showing ${startItem} to ${endItem} of ${totalItems} Entries
                    </span>
                    <div class="inline-flex mt-2 xs:mt-0">
                        <button id="prev-page" class="pagination-btn text-sm bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-l" ${currentPage === 1 ? 'disabled' : ''}>Prev</button>
                        ${buttonsHtml}
                        <button id="next-page" class="pagination-btn text-sm bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-r" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>
                    </div>
                `;
        }

        function calculateRankingScore(bot, stats) {
            const weights = {
                monthlyReturn: 0.30,
                sharpeRatio: 0.30,
                calmarRatio: 0.20,
                maxDrawdown: -0.10,
                recoveryTime: -0.10,
            };

            const metricPaths = {
                monthlyReturn: 'live_bot_expectation.expected_avg_return (%)',
                sharpeRatio: 'live_performance.Sharpe Ratio',
                calmarRatio: 'live_performance.Calmar Ratio',
                maxDrawdown: 'live_performance.Worst Expected Drawdown (%)',
                recoveryTime: 'live_performance.Maximum Recovery Time (Days)',
            };

            let score = 0;
            for (const key in weights) {
                const path = metricPaths[key];
                const rawValue = parseFloat(path.split('.').reduce((o, k) => (o || {})[k], bot)) || 0;
                const zScore = standardize(rawValue, stats[key].mean, stats[key].stdDev);
                score += (zScore * weights[key]);
            }

            return isNaN(score) ? 0 : score;
        }

        function updateCharts() {
            const selectedBots = allBotsData.filter(bot => selectedBotsForCharts.includes(bot.bot_id));
            createBarCharts(selectedBots);
            updateRiskPerformanceRadar(selectedBots, document.getElementById('performance-toggle').checked ? 'backtest' : 'live');
            createNewCharts(selectedBots);
            createQuarterlyChart(selectedBots);
        }

        function exportTableToCSV() {
            const isBacktest = document.getElementById('table-data-toggle').checked;
            const headers = Array.from(document.querySelectorAll('#main-table-head th')).map(th => th.innerText.trim()).slice(0, -1);

            const rows = allBotsData.map(bot => {
                const perfKey = isBacktest ? 'backtest_performance' : 'live_performance';
                const expectKey = isBacktest ? 'backtest_bot_expectation' : 'live_bot_expectation';
                return [
                    bot.rank,
                    bot.bot_name,
                    bot[expectKey]?.['expected_avg_return (%)']?.toFixed(2) ?? 'N/A',
                    bot[perfKey]?.['Return (%)']?.toFixed(2) ?? 'N/A',
                    bot[perfKey]?.['Number of Trades'] ?? 'N/A',
                    bot[perfKey]?.['Market Change (%)']?.toFixed(2) ?? 'N/A',
                    bot[perfKey]?.['Worst Expected Drawdown (%)']?.toFixed(2) ?? 'N/A',
                    bot[perfKey]?.['Maximum Recovery Time (Days)'] ?? 'N/A',
                    parseInt(bot[perfKey]?.['Number of Execution Days']) || 'N/A',
                    bot[perfKey]?.['Average Position’s Duration'] ?? 'N/A',
                    bot.score.toFixed(2),
                ].join(',');
            });

            const csvContent = "data:text/csv;charset=utf-8," + [headers.join(','), ...rows].join('\n');
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "crypto_bot_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- INITIALIZATION AND EVENT LISTENERS ---
        async function initializeDashboard() {
            try {
                const [rawBotsData, fetchedReportData] = await Promise.all([fetchBotData(), fetchReportData()]);
                reportData = fetchedReportData;

                const uniqueBotsMap = new Map();
                rawBotsData.forEach((bot, index) => {
                    bot.bot_id = `bot_${index}`;
                    const existingBot = uniqueBotsMap.get(bot.bot_name);
                    const currentReturn = bot.live_bot_expectation?.['expected_avg_return (%)'] || -Infinity;
                    if (!existingBot || currentReturn > (existingBot.live_bot_expectation?.['expected_avg_return (%)'] || -Infinity)) {
                        uniqueBotsMap.set(bot.bot_name, bot);
                    }
                });
                allBotsData = Array.from(uniqueBotsMap.values());

                // Pre-calculate Mean and StdDev for ranking and scaling
                const rankingMetricKeys = ['monthlyReturn', 'sharpeRatio', 'calmarRatio', 'maxDrawdown', 'recoveryTime'];
                const rankingStats = rankingMetricKeys.reduce((acc, key) => {
                    const values = allBotsData.map(b => {
                        if (key === 'monthlyReturn') return parseFloat(b.live_bot_expectation?.['expected_avg_return (%)']) || 0;
                        if (key === 'sharpeRatio') return parseFloat(b.live_performance?.['Sharpe Ratio']) || 0;
                        if (key === 'calmarRatio') return parseFloat(b.live_performance?.['Calmar Ratio']) || 0;
                        if (key === 'maxDrawdown') return parseFloat(b.live_performance?.['Worst Expected Drawdown (%)']) || 0;
                        if (key === 'recoveryTime') return parseFloat(b.live_performance?.['Maximum Recovery Time (Days)']) || 0;
                        return 0;
                    });
                    const mean = calculateMean(values);
                    acc[key] = { mean: mean, stdDev: calculateStdDev(values, mean) };
                    return acc;
                }, {});

                allBotsData.forEach(bot => bot.score = calculateRankingScore(bot, rankingStats));
                allBotsData.sort((a, b) => b.score - a.score);
                allBotsData.forEach((bot, index) => bot.rank = index + 1);

                // Pre-calculate stats for all radar chart metrics
                const detailMetricConfigs = [
                    { key: 'expected_avg_return (%)', abs: false }, { key: 'Sharpe Ratio', abs: false },
                    { key: 'Win Rate (%)', abs: false }, { key: 'Max Drawdown (%)', abs: true },
                    { key: 'Maximum Recovery Time (Days)', abs: true }
                ];

                detailMetricConfigs.forEach(config => {
                    const values = allBotsData.flatMap(bot => [
                        (bot.live_performance[config.key] ?? bot.live_bot_expectation[config.key]) || 0,
                        (bot.backtest_performance[config.key] ?? bot.backtest_bot_expectation[config.key]) || 0
                    ]).map(v => parseFloat(v) || 0).map(v => config.abs ? Math.abs(v) : v);
                    const mean = calculateMean(values);
                    globalMetricsStats[config.key] = { mean: mean, stdDev: calculateStdDev(values, mean) };
                });

                const botSelectorContainer = document.getElementById('bot-selector-container');
                allBotsData.forEach(bot => {
                    const checkboxId = `bot-checkbox-${bot.bot_id}`;
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('flex', 'items-center', 'bot-selector-item');
                    wrapper.innerHTML = `
                            <input id="${checkboxId}" value="${bot.bot_id}" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                            <label for="${checkboxId}" class="ml-2 block text-sm text-gray-900 truncate" title="${bot.bot_name}">${bot.rank}. ${bot.bot_name}</label>
                        `;
                    botSelectorContainer.appendChild(wrapper);
                });

                selectedBotsForCharts = allBotsData.slice(0, 10).map(b => b.bot_id);
                selectedBotsForCharts.forEach(botId => {
                    document.getElementById(`bot-checkbox-${botId}`).checked = true;
                });

                document.getElementById('bot-selector-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    document.querySelectorAll('.bot-selector-item').forEach(item => {
                        const label = item.querySelector('label').textContent.toLowerCase();
                        item.style.display = label.includes(searchTerm) ? '' : 'none';
                    });
                });

                document.getElementById('reset-bot-selector').addEventListener('click', () => {
                    document.querySelectorAll('.bot-selector-item input').forEach(cb => cb.checked = false);
                    selectedBotsForCharts = allBotsData.slice(0, 10).map(b => b.bot_id);
                    selectedBotsForCharts.forEach(botId => {
                        const checkbox = document.getElementById(`bot-checkbox-${botId}`);
                        if (checkbox) checkbox.checked = true;
                    });
                    updateCharts();
                });

                botSelectorContainer.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        const checkedCheckboxes = botSelectorContainer.querySelectorAll('input[type="checkbox"]:checked');
                        if (checkedCheckboxes.length > 10) {
                            alert('You can select a maximum of 10 bots.');
                            e.target.checked = false;
                            return;
                        }
                        selectedBotsForCharts = Array.from(checkedCheckboxes).map(cb => cb.value);
                        updateCharts();
                    }
                });

                document.getElementById('start-date').value = '2025-01-01';
                document.getElementById('end-date').value = new Date().toISOString().split('T')[0];

                updateCharts();
                render();

                document.getElementById('export-csv-btn').addEventListener('click', exportTableToCSV);
                document.getElementById('apply-filter-btn').addEventListener('click', updateCharts);
                document.getElementById('bot-search').addEventListener('input', () => {
                    currentPage = 1;
                    render();
                });
                document.getElementById('table-data-toggle').addEventListener('change', render);

                document.getElementById('main-table-head').addEventListener('click', (e) => {
                    const header = e.target.closest('.sortable');
                    if (!header) return;

                    const key = header.dataset.sortKey;
                    if (currentSort.key === key) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.key = key;
                        currentSort.direction = 'asc';
                    }

                    document.querySelectorAll('#main-table-head .sortable').forEach(th => th.removeAttribute('data-sort-dir'));
                    header.setAttribute('data-sort-dir', currentSort.direction);
                    currentPage = 1;
                    render();
                });

                document.getElementById('bots-table-body').addEventListener('click', (e) => {
                    const button = e.target.closest('.view-details-btn');
                    if (button) {
                        openModal(button.dataset.botId);
                    }
                });

                document.getElementById('performance-toggle').addEventListener('change', (e) => {
                    const mode = e.target.checked ? 'backtest' : 'live';
                    const selectedBots = allBotsData.filter(bot => selectedBotsForCharts.includes(bot.bot_id));
                    updateRiskPerformanceRadar(selectedBots, mode);
                });

                document.getElementById('pagination-controls').addEventListener('click', (e) => {
                    if (e.target.id === 'prev-page') {
                        currentPage--;
                    } else if (e.target.id === 'next-page') {
                        currentPage++;
                    } else if (e.target.dataset.page) {
                        currentPage = parseInt(e.target.dataset.page);
                    }
                    render();
                });

            } catch (error) {
                console.error("Failed to initialize dashboard:", error);
                document.body.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl text-red-600">Error Loading Data</h2><p>${error.message}</p><p>Please ensure the JSON and Markdown files are in the same directory and your browser can access them.</p></div>`;
            } finally {
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }

        function periodToDate(period) {
            if (!period) return new Date(0);

            if (period.includes('/')) { // YYYY/MM/DD format
                const parts = period.split('/');
                if (parts.length === 3) {
                    return new Date(parts[0], parts[1] - 1, parts[2]);
                }
            }
            if (period.includes('Q')) { // YYYY-Q# or YYYYQ# format
                const match = period.match(/(\d{4})-?Q(\d)/);
                if (match) {
                    const year = parseInt(match[1]);
                    const quarter = parseInt(match[2]);
                    const month = (quarter - 1) * 3;
                    return new Date(year, month, 1);
                }
            }
            if (/^\d{4}$/.test(period)) { // YYYY format
                return new Date(period, 0, 1);
            }
            return new Date(0); // Invalid date
        }

        async function createQuarterlyChart(bots) {
            destroyChart('quarterlyPerformanceChart');

            const timeframe = document.getElementById('timeframe-selector').value;
            const startDateStr = document.getElementById('start-date').value;
            const endDateStr = document.getElementById('end-date').value;
            const isBacktest = document.getElementById('quarterly-data-toggle').checked;

            const startDate = startDateStr ? new Date(startDateStr) : null;
            const endDate = endDateStr ? new Date(endDateStr) : null;

            let allLabels = new Set();
            bots.forEach(bot => {
                const reportKey = isBacktest ? 'backtest_quarterly_report' : 'live_quarterly_report';
                if (!bot[reportKey] || !Array.isArray(bot[reportKey])) return;

                bot[reportKey].forEach(report => {
                    const period = report['Time Period'] || report['Time Periods'];
                    if (!period) return;

                    const reportDate = periodToDate(period);
                    if (reportDate.getTime() === 0) return;

                    let periodType;
                    if (period.includes('/')) periodType = 'weekly';
                    else if (period.includes('Q')) periodType = 'quarterly';
                    else if (/^\d{4}$/.test(period)) periodType = 'yearly';

                    if (periodType !== timeframe) return;
                    if (startDate && reportDate < startDate) return;
                    if (endDate && reportDate > endDate) return;

                    allLabels.add(period);
                });
            });
            const sortedLabels = Array.from(allLabels).sort((a, b) => periodToDate(a) - periodToDate(b));

            const datasets = bots.map((bot, index) => {
                const reportKey = isBacktest ? 'backtest_quarterly_report' : 'live_quarterly_report';
                if (!bot[reportKey] || !Array.isArray(bot[reportKey])) return null;

                const reportMap = new Map(
                    bot[reportKey].map(r => [r['Time Period'] || r['Time Periods'], r])
                );

                let cumulativeReturn = 0;
                let hasStarted = false;

                const data = sortedLabels.map(label => {
                    const report = reportMap.get(label);
                    if (report) {
                        hasStarted = true;
                        const returnValue = report['Initial Capital Return (%)'] || report['∑ Profit (%)'] || 0;
                        cumulativeReturn += returnValue;
                        return {
                            x: periodToDate(label).getTime(),
                            y: cumulativeReturn
                        };
                    } else {
                        return {
                            x: periodToDate(label).getTime(),
                            y: hasStarted ? cumulativeReturn : null
                        };
                    }
                });

                const color = `hsl(${(index * 360 / bots.length)}, 70%, 50%)`;
                return {
                    label: bot.bot_name,
                    data: data,
                    borderColor: color,
                    backgroundColor: `hsla(${(index * 360 / bots.length)}, 70%, 50%, 0.2)`,
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'y'
                };
            }).filter(Boolean);

            const ctx = document.getElementById('quarterlyPerformanceChart').getContext('2d');
            chartInstances.quarterlyPerformanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: timeframe === 'weekly' ? 'week' : (timeframe === 'yearly' ? 'year' : 'quarter'),
                                tooltipFormat: 'PP'
                            },
                            title: { display: true, text: 'Time Period' }
                        },
                        y: {
                            title: { display: true, text: 'Cumulative Return (%)' },
                            position: 'left'
                        }
                    }
                }
            });
        }

        document.querySelector('.modal-overlay').addEventListener('click', closeModal);
        document.querySelectorAll('.modal-close').forEach(el => el.addEventListener('click', closeModal));
        document.addEventListener('keydown', e => e.key === 'Escape' && closeModal());

        initializeDashboard();
    });
</script>
</body>
</html>
